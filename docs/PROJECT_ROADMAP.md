# 项目整体思路与路线图

## 🎯 项目目标

从大量GIS平台的JSON测试文件中学习，训练AI模型能够：
- **输入**：用户的自然语言描述（如："创建一个新的MS电缆对象"）
- **输出**：完整的GIS测试JSON代码

## 📊 核心思路

### 问题定义

我们有很多JSON文件，每个文件表示在GIS平台上的一系列操作/测试。现在需要：
1. 让AI理解这些JSON代码的含义
2. 训练模型能够根据用户指令生成类似的JSON代码

### 解决方案：双粒度建模

#### 文件级（File-Level）
- **目标**：理解整个工作流的业务目标
- **作用**：用于检索相似案例（RAG）
- **示例**：
  - JSON文件 → "在电力网络中创建MS和HS电缆对象并设置属性"

#### 步骤级（Step-Level）
- **目标**：理解每个具体操作步骤
- **作用**：用于模型训练（指令→代码）
- **示例**：
  - 步骤1 → "打开MS电缆编辑器"
  - 步骤2 → "创建坐标为(186355533, 439556907)的MS电缆对象"
  - 步骤3 → "设置电缆为3相状态"

## 🔄 完整流程

### 阶段1：数据准备（生成训练数据）

```
📁 原始JSON测试文件 (data/raw/)
    ├── template/           ← 高质量模板
    ├── test_data_1/        ← 普通测试数据
    └── test_data_hv/       ← 其他测试数据
         │
         ▼ [工具1: workflow_parser.py]
         │  解析扁平化JSON → 结构化工作流
         │
📄 结构化工作流 (parsed_workflows.jsonl)
    包含：
    ├── 文件元数据（应用名、数据库、对象类型等）
    └── 步骤详情（模块、方法、参数等）
         │
         ▼ [工具2: instruction_generator.py]
         │  使用Qwen/OpenAI生成用户指令
         │
📋 训练数据集
    ├── file_level_instructions.jsonl    ← 文件级指令
    └── step_level_instructions.jsonl    ← 步骤级指令
```

**关键点**：
- 使用LLM（Qwen/OpenAI）模拟用户会如何描述这些操作
- 生成的指令作为**训练目标值**（标签）
- JSON代码作为**训练输入**

### 阶段2：建立映射关系

训练数据的格式：

**文件级训练样本**：
```json
{
  "instruction": "在电力网络中创建MS和HS电缆对象并设置属性",
  "input": "",
  "output": "{完整的JSON工作流代码...}"
}
```

**步骤级训练样本**：
```json
{
  "instruction": "创建坐标为(186355533, 439556907)的MS电缆对象",
  "input": "{前序步骤的上下文...}",
  "output": "{当前步骤的JSON代码...}"
}
```

### 阶段3：模型训练

```
训练数据 (step_level_instructions.jsonl)
    │
    ▼ [使用LoRA微调]
    │  基础模型: Qwen2.5-Coder-7B
    │  方法: LoRA (低秩适配)
    │  硬件: Colab T4 GPU (免费)
    │
训练完成的模型
    能够: 用户指令 → JSON代码
```

**训练目标**：
- 学习从自然语言指令到JSON代码的映射
- 理解GIS操作的语义（打开编辑器、创建对象、设置属性等）

### 阶段4：推理生成

```
用户输入: "创建一个新的MS电缆"
    │
    ├──► [RAG检索模块]
    │    └─ 从file_level_instructions中检索相似案例
    │       找到类似的工作流作为参考
    │
    └──► [训练好的模型]
         └─ 根据用户指令 + 检索到的示例
            逐步生成JSON代码
              │
              ▼
    完整的JSON测试代码
```

## 🛠️ 核心工具链

### 已实现 ✅

1. **workflow_parser.py** - JSON解析器
   - 输入：原始JSON文件
   - 输出：结构化工作流（parsed_workflows.jsonl）

2. **instruction_generator.py** - 指令生成器
   - 输入：结构化工作流
   - 输出：用户指令（file/step level）
   - 支持：Qwen、OpenAI

3. **generate_instructions_qwen.py** - 批处理脚本
   - 命令行工具，批量处理所有文件
   - 支持测试模式、高质量优先等选项

4. **analyze_data.py** - 数据分析
   - 统计分析、质量评估

### 待实现 🚧

5. **RAG检索模块** (src/rag/)
   - 向量化file_level_instructions
   - 相似度检索

6. **训练脚本** (src/training/)
   - LoRA微调
   - 训练监控

7. **推理引擎** (src/inference/)
   - 结合RAG + 生成模型
   - 端到端生成

8. **Web界面** (src/app/)
   - Gradio交互界面

## 📈 当前进度

```
[████████████░░░░░░░░] 60%

✅ 阶段1: 数据准备         100% 完成
🚧 阶段2: 模型训练         20%  进行中
🔜 阶段3: RAG检索          0%   计划中  
🔜 阶段4: 推理系统         0%   计划中
```

## 🎓 关键概念

### 为什么需要"模拟用户指令"？

因为我们的训练数据只有JSON代码，没有对应的用户描述。所以需要：
1. 使用LLM（Qwen）来"反向"生成用户可能会怎么描述这些操作
2. 这些生成的指令作为训练的**标签**
3. 让模型学习：指令 → 代码

### 为什么是双粒度？

1. **文件级**：用于快速检索相似的完整案例（RAG）
2. **步骤级**：用于精细化训练，逐步生成代码

这样结合可以：
- 先检索到相似的模板（提供上下文）
- 再逐步生成具体的代码（细粒度控制）

### 文件级和步骤级的关系

```
文件级：整体目标描述
    └─ 步骤1：具体操作1
    └─ 步骤2：具体操作2  ← 包含前序步骤的上下文
    └─ 步骤3：具体操作3  ← 包含前序步骤的上下文
```

每个步骤的指令生成时，会包含前序步骤的上下文，保证连贯性。

## 💡 下一步行动

### 立即可做

1. ✅ 运行数据处理流程，生成训练数据
2. ✅ 分析生成的指令质量
3. ✅ 准备训练数据格式

### 接下来

4. 🚧 设计训练数据的最终格式（适配LoRA训练）
5. 🚧 编写LoRA微调脚本
6. 🔜 实现RAG检索模块
7. 🔜 构建端到端推理系统

## 📞 总结

**大体逻辑**：
1. 📄 有很多GIS测试JSON文件
2. 🤖 使用LLM生成对应的用户指令（模拟用户如何描述）
3. 🗂️ 建立指令→代码的映射数据集
4. 🎓 训练模型学习这个映射关系
5. 🚀 部署后可以根据用户指令生成JSON代码

**核心价值**：
- 从代码自动生成训练数据（无需人工标注）
- 双粒度保证检索和生成的质量
- 成本低廉（<¥5），可复现性强
